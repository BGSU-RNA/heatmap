#!/usr/bin/env python

import os
import re
import csv
import sys
import json

import itertools as it

import requests

URL = 'http://rna.bgsu.edu/rna3dhub/rest/getCoordinates'
IMAGE_URL = 'static/img/{0}/{0}_{1}_exemplar.png'


def generate_data(header, rows):
    data = {'items': {}, 'pairs': []}

    names = map(lambda r: r[1], rows)

    for row in it.imap(lambda r: dict(it.izip(header, r)), rows):
        first = row['Base combination']
        family = row['Family']
        known = True
        units = [row['NT1ID'], row['NT2ID']]
        id_of = lambda seq: '%s-%s' % (family, seq)
        url = None

        pdb = row['PDBID']
        if row['Resolution'] == 'NaN':
            resolution = None
        else:
            resolution = float(row['Resolution'])

        if 'MODEL' in pdb:
            pdb = 'Modeled'
            resolution = None
            known = False
        elif 'CURATED' in pdb:
            pdb = pdb.split('_')[1]

        # We have to detect if we can get the coordinates for the given item.
        # The only way to do this in cases where we have a unit ids is to make
        # a request for that set of coordiantes and see if it worked.
        if known:
            url = IMAGE_URL.format(family, first)
            response = requests.post(URL, data={'coord': ','.join(units)})
            if 'MODEL' not in response.text:
                known = False

        data['items'][first] = {
            'id': id_of(first),
            'units': units,
            'pdb': pdb,
            'resolution': resolution,
            'group': row['LW 2002 subgroup'],
            'family': family,
            'distance': float(row['C1*-C1* distance']),
            'count': int(row['Count']),
            'sequence': first,
            'coordinates_exist': known,
            'url': url
        }


        for key in names:
            if re.match('^[ACGUacgu]{2}$', key):
                data['pairs'].append({
                    'id': '%s-%s-%s' % (family, first, key),
                    'exists': (key != first) or known,
                    'idi': float(row[key]),
                    'items': [first, key],
                    'item_ids': [id_of(first), id_of(key)]
                })

    return data


def load_data(raw, family):
    reader = csv.reader(raw, delimiter=',')
    rows = [row for row in reader]
    header = rows.pop(0)

    sequences = filter(lambda seq: re.match('^[ACGU]{2}$', seq), header)
    if len(sequences) == len(set(sequences)):
        return generate_data(header, rows)

    f_index = header.index('Family')
    c_index = header.index('Base combination')

    offset = header.index(sequences[0])
    for index, row in enumerate(rows):
        family = row[f_index]
        sequence = row[c_index]
        if family[1] == family[2] or family[1].lower() != family[2].lower():
            name = sequence
        elif family[1] == family[1].upper():
            name = sequence[0] + sequence[1].lower()
        else:
            name = sequence[0].lower() + sequence[1]
        row[c_index] = name
        header[offset + index] = name

    return generate_data(header, rows)


def add_missing_items(data):
    known = [key.upper() for key in data['items'].keys()]
    item = data['items'][data['items'].keys()[0]]
    pdb = item['pdb']
    family = item['family']

    nts = ['A', 'C', 'G', 'U']
    possible = set([''.join(pair) for pair in zip(nts, nts)])
    missing = possible - set(known)
    for sequence in missing:
        data['items'][sequence] = {
            'id': '%s-%s' % (family, sequence),
            'units': [],
            'pdb': pdb,
            'resolution': None,
            'group': None,
            'family': family,
            'distance': None,
            'count': 0,
            'sequence': sequence,
            'coordinates_exist': False,
            'url': None
        }


def save(data):
    json.dump(data, sys.stdout)
   # json.dumps(data)


def main(filename):
    name = os.path.basename(filename)[0:3]
    with open(filename, 'rb') as raw:
        data = load_data(raw, name)
    add_missing_items(data)
    save(data)

if __name__ == '__main__':
    main(sys.argv[1])
